$def with (name)

$if name:
    I just wanted to say <em>hello</em> to $name.
$else:
    <em>Hello</em>, world!

<!DOCTYPE html> 
<html>
  <head>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script src="./static/jawsjs/jaws.js"></script>
    <link type="text/css" rel="stylesheet" href="./static/style.css" />
    <title>Puzzle Game</title>
  </head>
<body>

  <canvas width=600 height=500></canvas>
  Move with arrow keys.
  <div id="live_info"></div>

  <script>

    // CONSTANTS
    var X_SPEED = 10
    var Y_SPEED = 60
    var BOARD_WIDTH = 6
    var BOARD_HEIGHT = 10
    var ITEM_WIDTH = 40


    var COLORS = new Array("RED","GREEN","BLUE","YELLOW","PURPLE","ORANGE","EMPTY","WHITE","UNSTABLE")
    var RED = 0
    var GREEN = 1
    var BLUE = 2
    var YELLOW = 3
    var UNSTABLE = COLORS.length - 1
    var WHITE = COLORS.length - 2
    var EMPTY = COLORS.length - 3

    var COLOR = {
      RED : 0,
      GREEN : 1,
      BLUE : 2,
      YELLOW : 3,
      PURPLE : 4,
      ORANGE : 5,
      EMPTY : 6,
      WHITE : 7
    }

    // GLOBALS
    var player_name = "Kris"
    var player_level = 1
    var player_stage = 1
    var control_scheme = 1
    var game_mode = 1

    function Game() {
      var player
      var viewport
      var need_to_restart = false

      /* Called once when a game state is activated. Use it for one-time setup code. */
      this.setup = function() {
        // live_info = document.getElementById("live_info")
        live_info = $("live_info")

        viewport = new jaws.Viewport({max_x: 600, max_y: 500})

        player = new Player(3,0)

        player.board.fill(player_level,player_stage)

        console.log("setup game")
        console.log("player_name = " + player_name)
        console.log("live_info = " + live_info)

        jaws.context.mozImageSmoothingEnabled = false;  // non-blurry, blocky retro scaling
        jaws.preventDefaultKeys(["w", "s", "a", "d", "k"])
      }

      /* update() will get called each game tick with your specified FPS. Put game logic here. */
      this.update = function() {

        if (need_to_restart)
          jaws.start(Game)

        // Player Controls

        jaws.on_keydown(["left","a"], function() {
          if(player.x > 0) {
            if (player.canMoveX(-1)) player.moveX(-1)
            else {
              // drop minimum amount of items on hand so hand can move left
              var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x - 1].items.length)
              if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x - 1].items.length > 0) {
                player.drop(player.board.stacks[player.x],drop_amount)
                player.moveX(-1)
              }

            }
          } 
          console.log("player (" + player.x + " , " + player.y + ")")
        })
        jaws.on_keydown(["right","d"], function() {
          if(player.x < BOARD_WIDTH - 1) {
            if (player.canMoveX(1)) player.moveX(1)
            else {
              // drop minimum amount of items on hand so hand can move right
              var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x + 1].items.length)
              if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x + 1].items.length > 0) {
                player.drop(player.board.stacks[player.x],drop_amount)
                player.moveX(1)
              }

            }
          } 
          console.log("player (" + player.x + " , " + player.y + ")")
        })
        jaws.on_keydown(["up","w"], function() {
          if(player.y < BOARD_HEIGHT-1)player.y += 1
          console.log("player (" + player.x + " , " + player.y + ")")
        })
        jaws.on_keydown(["down","s"], function() {

          if(player.hand.items.length>0) {
            player.drop(player.board.stacks[player.x],player.hand.items.length)              
          } else if(player.y > 0) player.y -= 1


          console.log("player (" + player.x + " , " + player.y + ")")
        })
        jaws.on_keydown(["z","k"], function() {
          if(control_scheme == 1) {
            if(player.hand.items.length == 0) {          
              player.grab(player.board.stacks[player.x],player.board.stacks[player.x].items.length)
            } else {
              player.drop(player.board.stacks[player.x],player.hand.items.length)
            }
          }
        })
        jaws.on_keydown(["x","j","space"], function() {
          if(player.hand.items.length == 0) {
            //grab depth determined by cursor y-position
            var depth = player.board.stacks[player.x].items.length - player.y
            player.grab(player.board.stacks[player.x],depth)
          } else {
            //drop
            player.drop(player.board.stacks[player.x],1)
          }
        })
        jaws.on_keydown("r", function() {
          jaws.start(Game)
        })  
        jaws.on_keydown(["enter","esc"], function() {
          jaws.start(MenuState)
        })  

        player.update()

        live_info.innerHTML = jaws.game_loop.fps + " fps. Player: " + parseInt(player.x) + "/" + parseInt(player.y) + ". "
        live_info.innerHTML += "Viewport: " + parseInt(viewport.x) + "/" + parseInt(viewport.y) + "."

      }

      /* Directly after each update draw() will be called. Put all your on-screen operations here. */
      this.draw = function() {
        jaws.clear()

        // the viewport magic. wrap all draw()-calls inside viewport.apply and it will draw those relative to the viewport.
        viewport.apply( function() {
          player.draw()
        });
      }

      /* Constructor for Player */
      function Player(x,y) {

        // player consists of a board and hand
        // board consists of six stacks, hand is a stack
        // stack consists of items
        // an item has type and color

        this.x = x
        this.y = y
        this.board = new Board(this)
        this.hand = new Stack(this.board) // passing in Player board
        this.cursor_speed = X_SPEED

        this.sprite_sheet = new jaws.SpriteSheet({
          image: "./static/images/cursor.gif", frame_size: [40,20]})

        this.cursor_top = new jaws.Sprite({x:this.board.posx(x), y:this.board.posy(y), image: this.sprite_sheet.frames[0]})
        this.cursor_bottom = new jaws.Sprite({x:this.board.posx(x), y:(this.board.posy(y)+20), image: this.sprite_sheet.frames[1]})

        // player timer
        this.timer = new Timer(this)

        // check if player hand can move in x direction
        this.canMoveX = function(x) {

          // check if stacks overlap
          if (this.board.stacks[this.x + x].items.length + this.hand.items.length > BOARD_HEIGHT)
            return false

          return true
        }

        // move the player hand in x direction
        this.moveX = function(x) {

          this.x += x

          //update each item in hand
          for (var i=0; i<this.hand.items.length; i++) {
            var item = this.hand.items[i]
            item.x = this.x
            item.sprite.dx = this.board.posx(this.x)
          }
        }

        // grab depth amount of items from stack
        this.grab = function(stack,depth) {

          // move the cursor quickly to the top of the screen
          this.cursor_speed = Y_SPEED

          for(var i=0; i<depth; i++) {

            var item = stack.items.pop()

            // stop pushing to hand when breaking item encountered
            if (item.breaking)
              break

            // push top of stack to hand
            this.hand.items.push(item)

            // update hand position
            // var item = this.hand.items.pop()
            item.x = this.x
            item.y = BOARD_HEIGHT - 1 - i
            item.stack = this.hand

            // update sprite destination
            item.sprite.dx = this.board.posx(item.x)
            item.sprite.dy = this.board.posy(item.y)

            // reset chain
            item.chain = 0

          }
        }

        // drop depth amount of items onto stack
        this.drop = function(stack,depth) {

          var hand_items = this.hand.items
          var stack_items = stack.items

          for(var i=0; i<depth; i++) {
            stack.items.push(hand_items.pop())

            // update stack items
            var item = stack_items.pop()
            item.x = this.x
            item.y = stack_items.length
            item.stack = stack

            // update sprite destination
            item.sprite.dx = this.board.posx(item.x) 
            item.sprite.dy = this.board.posy(item.y)

            stack_items.push(item)

          }

          // reset chain for all items on stack if none are breaking
          if (!stack.itemsBreaking())
            stack.setChain(stack.items,0)

          // check for matches
          stack.checkForMatches()

          // reposition player's y position if hand is now empty
          if (hand_items.length == 0) 
            this.y = stack_items.length - depth // at item at bottom of hand stack          

        }

        // update player sprites positions
        this.updatePlayerSprites = function(dx,dy) {

          var cursor_top = this.cursor_top
          var cursor_bottom = this.cursor_bottom

          cursor_top.dx = cursor_bottom.dx = this.board.posx(this.x)

          if (this.hand.items.length == 0) {
            cursor_top.dy = this.board.posy(this.y)
            cursor_bottom.dy = this.board.posy(this.y) + cursor_bottom.height
          } else {
            cursor_top.dy = this.board.posy(BOARD_HEIGHT-1)
            cursor_bottom.dy = this.board.posy(BOARD_HEIGHT - this.hand.items.length) + cursor_bottom.height
          }

          spriteMove(cursor_top,X_SPEED,this.cursor_speed)
          spriteMove(cursor_bottom,X_SPEED,this.cursor_speed)

          // reset cursor speed when it reaches dy
          if (this.hand.items.length == 0 && cursor_top.dy == cursor_top.y) this.cursor_speed = X_SPEED


        }

        // update player sprites, board sprites, etc.
        this.update = function() {

          // update timer
          this.timer.update()

          // update cursor position
          var cursor = this.cursor

          // cursor.dx = this.board.posx(this.x)
          // cursor.dy = this.board.posy(this.y)
          // spriteMove(cursor,X_SPEED,X_SPEED)

          this.updatePlayerSprites(this.board.posx(this.x),this.board.posy(this.y))

          this.board.update() // updates sprites for each stack
          this.hand.update()  // updates sprites for items in hand

        }

        // draw everything that was just updated
        this.draw = function() {
          this.board.draw()
          this.hand.draw()
          // jaws.context.drawImage(jaws.assets.get("images/cursor.gif"), this.cursor.x, this.cursor.y)

          this.cursor_top.draw()
          this.cursor_bottom.draw()
        }

      }

      /* Constructor for board */
      function Board(player) {
        this.player = player
        this.stacks = new Array()
        this.board = new jaws.Sprite({x:ITEM_WIDTH,y:ITEM_WIDTH,image:"./static/images/BOARD.gif",anchor:"left"})

        this.block_count = [0,0,0,0,0,0,0,0]
        this.flask_count = [0,0,0,0,0,0,0,0,0]
        this.robot_count = [0,0,0,0,0,0]

        this.effects = new Array()

        // fill up the board with items depending on level-stage
        this.fill = function(level,stage) {

          console.log("Setting up level " + level + "-" + stage + ".")

          // determine what needs to be placed on the board for this level-stage
          var total_flasks = level + 1 // except for 1-1, 1-2
          if (level == 1 && (stage == 1 || stage == 2))
            total_flasks = 1
          console.log("total_flasks = " + total_flasks)

          var total_robots = level + stage // except for level 1
          if (level == 1) {
            total_robots = stage
          }
          console.log("total_robots = " + total_robots)

          var total_blocks = 6 * (level + 1) + stage // except for 1-1,1-2,1-3,1-4,1-5
          if (level == 1) {
            if (stage == 1) total_blocks = 5
            else if (stage == 2) total_blocks = 6
            else if (stage == 3) total_blocks = 10
            else if (stage == 4) total_blocks = 12
            else if (stage == 5) total_blocks = 14
          }
          console.log("total_blocks = " + total_blocks)

          var total_colors = level + 1 // except for 1-1,1-2
          if (level == 1) {
            if (stage <= 2) total_colors = 1
          } else if (level == 6) total_colors = 6
          console.log("total_colors = " + total_colors)

          // put everything that's needed into an Array then randomize
          var items_array = new Array() // will contain tuple = [type,color]

          // put items in array for each color
          for (var c=0; c < total_colors; c++) {

            // put robots into array
            var robots_of_color = total_robots / total_colors
            for (var r=0; r < robots_of_color; r++) {
              items_array.push([2,c])
              if (items_array.length >= total_robots) break
            }

            // put at least one flask for each color, fill up flasks with white for mode: 1
            items_array.push([1, (game_mode == 1) ? WHITE : EMPTY])

            // put at least three blocks for each color
            items_array.push([0,c])
            items_array.push([0,c])
            items_array.push([0,c])

            // for mode: 2
            if (game_mode == 2) {
              // put at least three white blocks for each color
              items_array.push([0,WHITE])
              items_array.push([0,WHITE])
              items_array.push([0,WHITE])
            }

          }

          console.log("item_count = " + items_array.length)

          // fill up with random blocks and flasks until total_blocks reached
          while (items_array.length < total_blocks) {

            var rand_color = Math.floor(Math.random()*7)

            if (rand_color > total_colors - 1) {
              items_array.push(
                [2,Math.floor(Math.random()*total_colors)]
              )
            } else if (rand_color < 6) {

              var rand_int = Math.floor(Math.random()*2)
              if (rand_int == 0) items_array.push([0,rand_color])
              else items_array.push([2,rand_color])
              
            }
            else {
              items_array.push([1,WHITE])
              console.log("color(" + WHITE + ")")
            }



            console.log(items_array[items_array.length - 1]) 

          }

          console.log("done filling up items_array")
          console.log("item_count = " + items_array.length)

          // shuffle the item_array
          fisherYates(items_array)
          for(var i=0; i < items_array.length; i++) {
            console.log("[" + items_array[i][0] + "," + items_array[i][1] + "]")
          }

          // push BOARD_WIDTH amount of stacks
          for (var i=0; i < BOARD_WIDTH; i++) {
            this.stacks.push(new Stack(this,level,i))
          }

          // randomly decide which stack to place items in
          while (items_array.length > 0) {
            
            var rand_stack = Math.floor(Math.random()*6)
            var this_stack = this.stacks[rand_stack]
            if (this_stack.items.length >= level + 3) {
              console.log("top of stack reached")
              continue
            }
            var item_top = items_array.pop()

            console.log("color(" + item_top[1] + ")")
            this_stack.items.push(
              new Item(this_stack,item_top[0],item_top[1],rand_stack,this_stack.items.length)
            )

          }

          // make sure that stacks don't contain matches
          for(var s=0; s < player.board.stacks.length; s++) {
            var this_stack = player.board.stacks[s]
            if (this_stack.checkForMatches()) {
              // will restart at the beginning of this.update()
              need_to_restart = true
            }  
          }

          // check if there are 5 blocks of some color
          for(var c=0; c < COLORS.length; c++) {
            if(this.block_count[c] == 5) {
              console.log("5 blocks of color(" + COLORS[c] + ") found. Resetting board.")
              need_to_restart = true
            }
          }

          console.log("block_count = " + this.block_count)
          console.log("flask_count = " + this.flask_count)
          console.log("robot_count = " + this.robot_count)
          
        }

        // provide position with respect to this Board
        this.posx = function(x) { return this.board.x + x * ITEM_WIDTH }
        this.posy = function(y) { return this.board.y + (BOARD_HEIGHT - 1 - y)*ITEM_WIDTH }

        // check if the player has reached a win/lose condition and act accordingly
        this.checkWinLose = function() {

          // win condition: robots cleared
          console.log("checking win condition")
          if (!(this.robot_count<[0,0,0,0,0,0] || [0,0,0,0,0,0]<this.robot_count)) { // array equality
            var record = player_name + " " + player_level + "-" + player_stage  + "-" + 
              ((game_mode == 1) ? "E" : "H") + " (" + this.player.timer.clock_text + ") W\n"
            saveRecord(record)
            window.alert(record)
            if (player_level == 1) {
              if (player_stage == 6) {
                player_level++
                player_stage = 1
              } else {
                player_stage++
              }
            } else if (player_level == 6){
              if (player_stage == 1) {
                player_stage = 6
              }
            } else {
              player_level++
            }
            // if (player_stage < 6) {
            //   player_stage++
            // } else {
            //   if (player_level < 6) {
            //     player_level++
            //     player_stage = 1
            //   }
            // }
            jaws.start(MenuState)
          }

          // lose condition: no more blocks/flasks to clear robots
          console.log("checking lose conditions")
          for (var c=0; c < 6; c++) {
            if (this.robot_count[c] > 0) {
              console.log("robots of color " + COLORS[c] + " still exist!")
              console.log("block count = " + this.block_count[c])
              console.log("flask_count = " + this.flask_count[c])
              if (this.block_count[c] < 3 && this.flask_count[c] <= 0) {

                console.log("lose!")
                var record = player_name + " " + player_level + "-" + player_stage  + "-" + 
                  ((game_mode == 1) ? "E" : "H") + " (" + this.player.timer.clock_text + ") L\n"
                saveRecord(record)
                window.alert(record)
                jaws.start(Game)
              }
            }
          }

          // check for necessary amount of white blocks
          var potential_white_potions = this.block_count[WHITE] / 3
          // window.alert ("checking for lose condition with potential_white_potions = " + potential_white_potions)
          if (potential_white_potions < this.flask_count[EMPTY]) {
                console.log("lose! Not enough white blocks to clear robots.")
                var record = player_name + " " + player_level + "-" + player_stage  + "-" + 
                  ((game_mode == 1) ? "E" : "H") + " (" + this.player.timer.clock_text + ") L\n"
                saveRecord(record)
                window.alert(record)
                jaws.start(Game)
          }


        }

        // check for items of specified type,color that are breaking
        this.checkForBreaking = function(type,color) {

          console.log("checking for breaking robot of color: " + color)

          for (var i=0; i < this.stacks.length; i++) {

            var this_stack = this.stacks[i]

            // check each item of the stack
            for (var j=0; j < this_stack.items; j++) {
              var this_item = this_stack.items[j]
              if (this_item.type == type && this_item.color == color) {
                console.log("breaking robot of color (" + color + ") found!")
                return true
              }
            }

          }

          return false

        }

        // update all stacks and effects in this board
        this.update = function() {

          // update stacks
          for (var s=0; s<this.stacks.length; s++) {
            this.stacks[s].update()
          }

          // update effects
          for (var e=0; e<this.effects.length; e++) {
            this.effects[e].update()
          }
        }

        // draw all stacks and effects on this board
        this.draw = function() {
          jaws.context.drawImage(jaws.assets.get("./static/images/BOARD.gif"), this.board.x, this.board.y )

          // draw all stacks in this board and containing items
          for (var i=0; i < this.stacks.length; i++) {
            this.stacks[i].draw()
          }

          jaws.context.font = "bold 25pt terminal";
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  "Black"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(player_name, this.board.x + BOARD_WIDTH * ITEM_WIDTH + 100, this.board.y + 25)

          jaws.context.font = "bold 25pt terminal";
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  "Black"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(this.player.timer.clock_text, this.board.x + BOARD_WIDTH * ITEM_WIDTH + 100, this.board.y + 75)

          // draw all effects on this board
          for (var e=0; e < this.effects.length; e++) {
            this.effects[e].draw()
          }
          
        }

      }

      /* Constructor for stack */
      function Stack(board,level,x) {

        this.board = board
        this.items = new Array()
        this.x = x

        // fill up the stack with level amount of items
        // DELETE THIS LATER (use this.fill instead. Board object will randomize)
        // for (var i=0; i < level; i++) {
        //   this.items.push(new Item(this,0,Math.floor(Math.random()*13),x,i))
        // }

        // check if the stack contains matches (3 or more consecutive blocks of same color)
        // return true if matches are found
        this.checkForMatches = function() {

          var match_found = false
          var matches = new Array()
          var items = this.items
          var match
          var item

          console.log("checking for matches")

          // loop through each item on the stack, adding them to matches[] array
          for (var i = 0; i < items.length; i++) {

            item = items[i]

            matches.push(item)
            match = matches[0]

            if (!match.matchBlocks(item)) {
              matches.pop()
              if (matches.length >= 3) {
                console.log("matches found!!! " + matches.length + " of color (" + matches[0].color + ")")
                // chain = this.matchesFound(matches)
                this.matchesFound(matches)
                match_found = true
                // item.chain = chain
              }
              matches = new Array()
              matches.push(item)
            }

            if (i == items.length - 1) {
              if (matches.length >= 3) {
                console.log("matches found!!! " + matches.length + " of color (" + matches[0].color + ")")
                // chain = this.matchesFound(matches)
                this.matchesFound(matches)
                match_found = true
              } 
            }
          }

          return match_found

        }

        // break matches and update their chains
        this.matchesFound = function(matches) { // matches, an array of blocks

          // keep track of block with largest chain
          var chain = 0

          // break matches
          for (var i=0; i<matches.length; i++) {          

            var match = matches[i]
            match.breaking = true
            match.chain += 1

            // update chain
            if (match.chain > chain) chain = match.chain
            match.chain = chain

          }

          // ensure that all matches have same chain
          this.setChain(matches,chain)

          console.log("breaking with chain = " + chain)

          console.log("matches:")
          for(var i=0; i<matches.length; i++) {
            console.log(matches[i].breaking)
          }

          return chain

        }

        // sets chain for all items passed in
        this.setChain = function(items,chain) {

          // go through each item and set its chain
          for (var i=0; i<items.length; i++) {
            var item = items[i]
            item.chain = chain
          }

        }

        // CURRENTLY NOT BEING USED
        this.removeItems = function(old_items) {
          this.items.splice(old_items[0].y,old_items.length)
          console.log("removing " + old_items[0].y,old_items.length)

          for (var i=0; i<this.items.length; i++) {
            var item = this.items[i]

            // drop item down if above old_items
            if (item.y > old_items[0].y) item.y -= old_items.length             
            item.sprite.dy = this.board.posy(item.y) // update sprite destination
          }
        }

        this.removeItem = function(old_item) {

          console.log("removing (" + old_item.type + ") of color (" + old_item.color + ")")

          // remove old item from items array
          this.items.splice(old_item.y,1)

          // update sprite destination for each item above old_item
          for (var i=0; i<this.items.length; i++) {
            var item = this.items[i]
            if (item.y > old_item.y) item.y -= 1
              item.sprite.dy = this.board.posy(item.y)
          }

          // update board count
          if (old_item.type == 0) {
            this.board.block_count[old_item.color]--
          } else if (old_item.type == 1) {
            this.board.flask_count[old_item.color]--
          } else if (old_item.type == 2) {
            this.board.robot_count[old_item.color]--
          }

          // check for win/lose only when blocks and robots are broken since flasks break first
          // but only check when items aren't breaking
          if (!old_item.stack.itemsBreaking()) {
            if (old_item.type == 0 || old_item.type == 1) {
              // if (old_item.color != WHITE)
                this.board.checkWinLose() // check for win/lose conditions
            } else if (old_item.type == 2) {
              // make sure that there are no other robots in the process of being removed
              var below = this.items[old_item.y - 1]
              if(below == undefined) {
                this.board.checkWinLose()
              } else {
                // if there is an item below, check if it is a robot of the same color
                if (!(below.type == 2 && below.color == old_item.color && below.breaking)) {
                  this.board.checkWinLose()
                }
              }

            }
          }

          // add splashes
          // if (old_item.type != 0)
          //   this.board.effects.push(new Splash(this,old_item.type,old_item.color,old_item.x,old_item.y,0))

          console.log("block_count = " + this.board.block_count)
          console.log("flask_count = " + this.board.flask_count)
          console.log("robot_count = " + this.board.robot_count)

          this.checkForMatches()

        }

        // check if there are items breaking on this stack
        this.itemsBreaking = function() {

          var breaking = false
          var item

          for (var i=0; i<this.items.length; i++) {
            item = this.items[i]
            if (item.breaking) {
              breaking = true
              break
            }
          }

          return breaking

        }

        // clear array of robots followed by array of flasks
        this.clearRobotsFlasks = function(robots_to_clear,flasks_to_clear) {

          for (var r = 0; r < robots_to_clear.length; r++) {

            var this_robot = robots_to_clear[r]

            this_robot.breaking = true

            // will put splashes here
            var robot_delay = this_robot.deathcounter + this_robot.splash_order
            this.board.effects.push(new Splash(this,this_robot.type,this_robot.color,this_robot.x,this_robot.y,robot_delay))

            // determine which sprites to use
            var death_color = "RED"
            if (this_robot.color == 1 || this_robot.color == 3)
              death_color = "YELLOW"
            else if (this_robot.color == 4 || this_robot.color == 5)
              death_color = "PURPLE"

            // update sprite data
            this_robot.sprite = new jaws.Sprite({x:this_robot.stack.board.posx(this_robot.x), y:this_robot.stack.board.posy(this_robot.y), anchor: "left"})
            var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + death_color + "_DEATH.gif", frame_size: [40,40], frame_duration: 20})
            this_robot.sprite.anim_default = anim.slice(0,6)

            var rand_color = Math.floor(Math.random()*WHITE)
            for (var c=0; c < rand_color; c++)
              this_robot.sprite.setImage(this_robot.sprite.anim_default.next())

            this_robot.sprite.dx = this_robot.stack.board.posx(this_robot.x)
            this_robot.sprite.dy = this_robot.stack.board.posy(this_robot.y)

          }

          for (var f = 0; f < flasks_to_clear.length; f++) {

            var this_flask = flasks_to_clear[f]

            this_flask.breaking = true

            // update sprite data       
            this_flask.sprite = new jaws.Sprite({x:this_flask.stack.board.posx(this_flask.x),y:this_flask.stack.board.posy(this_flask.y), anchor: "left"})
            var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_SPRITES.gif", frame_size: [40,40], frame_duration: 20 + Math.floor(Math.random()*((60-20) + 1))})
            this_flask.sprite.anim_default = anim.slice(0,6)

            this_flask.sprite.dx = this_flask.stack.board.posx(this_flask.x)
            this_flask.sprite.dy = this_flask.stack.board.posy(this_flask.y)

          }

        }

        // Stack .update() updates each item in the stack
        // update animations, counters, and chains
        // remove items if their death counters set off
        this.update = function() {

          // make sure to break flask last or the game will think lose condition is met
          // put flasks and robots to break into respective arrays
          var flasks_to_clear = new Array()
          var robots_to_clear = new Array()

          // copy stack items into new array so we can loop through all items
          // even if items are removed
          var stack_items = this.items.slice()

          // update each item
          for(var i=0; i<stack_items.length; i++) {
            var item = stack_items[i]
            var above = stack_items[i + 1]

            // for all items breaking (except UNSTABLE flasks)
            // NOTE: eventually will make updateX for X for any type of item
            // animation updates will happen there
            if (item.breaking) {

              // breaking animation
              if (item.type == 0) {
                if (item.sprite.width > 1) {
                  item.sprite.scaleWidth(.5)
                  item.sprite.dx += item.sprite.width / 2
                } else {
                  item.sprite.dx -= item.sprite.width / 2
                  item.sprite.scaleWidth(2)
                }

              // animate breaking flasks and robots
              } else {
                item.sprite.setImage(item.sprite.anim_default.next())
              }

              // update deathcounter
              item.deathcounter -= 1

              // add chain to items above
              if (above != undefined && !above.breaking) {
                above.chain = item.chain
              }

            } 

            // update items in transitory animation
            if (item.sleepcounter > 0) {
              item.sleepcounter -= 1
            }

            // remove item if death counter has expired
            if (item.deathcounter <= 0) {
              this.removeItem(item)
            }

            // animate robots
            if (item.type == 2) {
              item.sprite.setImage(item.sprite.anim_default.next())
            }

            // update item sprite positions
            spriteMove(item.sprite,X_SPEED,Y_SPEED)


            // check for breaking conditions
            // skip items on player hand
            if (item.stack != player.hand && !item.breaking) {

              // update flasks
              if (item.type == 1) {

                item.updateFlask(above)

              }

              // update robots
              else if (item.type == 2) {

                // clear robots

                var above = stack_items[i + 1]
                var below = stack_items[i - 1]
                if (above != undefined) {

                  // break robot and same-colored flask above
                  if (above.sleepcounter == 0 && above.color == item.color && above.type == 1) {

                    // item.breaking = true
                    // above.breaking = true

                    robots_to_clear.push(item)
                    flasks_to_clear.push(above)

                    above.chain += 1
                    item.chain += above.chain
                    item.splash_order = above.splash_order + 1

                    console.log("(" + above.color + ") flask breaking robot of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  // break if robot above is breaking
                  } else if (above.type == 2 && above.color == item.color && above.breaking) {

                    // item.breaking = true

                    robots_to_clear.push(item)

                    item.chain = above.chain
                    item.splash_order = above.splash_order + 1

                    console.log("robot combo of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  }
                }

                if (below != undefined) {

                  // break robot and same-colored flask below
                  if (below.sleepcounter == 0 && below.color == item.color && below.type == 1) {

                    // item.breaking = true
                    // below.breaking = true

                    robots_to_clear.push(item)
                    flasks_to_clear.push(below)

                    below.chain += 1
                    item.chain += below.chain
                    item.splash_order = below.splash_order + 1

                    console.log("(" + below.color + ") flask breaking robot of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  // break if robot below is breaking
                  } else if (below.type == 2 && below.color == item.color && below.breaking) {

                    // item.breaking = true

                    robots_to_clear.push(item)

                    item.chain = below.chain
                    item.splash_order = below.splash_order + 1

                    console.log("robot combo of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  }
                }
              }
            }
          }

          this.clearRobotsFlasks(robots_to_clear,flasks_to_clear)

        }

        this.draw = function() {
          for (var i=0; i<this.items.length;i++) {
            this.items[i].draw()
          }
        }

      }

      /* Constructor for item */
      function Item(stack,type,color,x,y) {

        console.log("making new item of type(" + type + "), color(" + COLORS[color] + ")")

        // an item has type and color
        this.stack = stack
        this.type = type
        this.color = color
        // if (color == EMPTY) this.type = 1
        // else if (color > WHITE) {
        //   this.type = 2
        //   this.color = color - 7
        // }
        this.x = x             // x position on the board
        this.y = y             // y position on the board
        this.breaking = false
        this.deathcounter = 40
        this.sleepcounter = 0  // used for transitory animations
                               // (eg: potion filling up, items exploding, etc.)
        this.chain = 0
        this.splash_order = 0

        var board = stack.board

        // set appropriate sprite for this item
        if (this.type == 0) {
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y),image:"./static/images/" + COLORS[color] + ".gif",anchor:"left"})
          board.block_count[color] += 1
        }
        else if (this.type == 1) {
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), image:"./static/images/POTION_" + COLORS[color] + ".gif",anchor:"left"})
          board.flask_count[color] += 1
        }
        else if (this.type == 2) {
          // create sprite for this robot        
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), anchor: "left"})
          var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + COLORS[this.color] + ".gif", frame_size: [40,40], frame_duration: 100})
          this.sprite.anim_default = anim.slice(0,5)
          board.robot_count[this.color] += 1
        }
        this.sprite.dx = this.stack.board.posx(x)
        this.sprite.dy = this.stack.board.posy(y)

        // update item count of the board


        this.matchBlocks = function(item) { // item to check if this matches with

          if (!this.breaking && this.type == 0 && item.type == this.type && item.color == this.color)
            return true

          return false

        }

        // update all flask items, called by Stack's .update()
        // above: the item above this flask, if any
        this.updateFlask = function(above) {

          // sanity check
          if (this.type != 1) return

          // check if blocks are breaking above
          // fill flask with potion of that color
          if (above != undefined) {
            if (above.breaking && above.type == 0) {

              // fill up the flask with potion of breaking color
              // only if the flask is not empty
              if (this.color == WHITE) {
                this.color = above.color 
                this.sleepcounter = 40
                console.log("sleepcounter = " + this.sleepcounter)

                // update sprite data
                this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), image:"./static/images/POTION_" + COLORS[above.color] + ".gif",anchor:"left"})
                this.sprite.dx = this.stack.board.posx(above.x)
                this.sprite.dy = this.stack.board.posy(above.y - 1)

                // update board count
                this.stack.board.flask_count[WHITE]--
                this.stack.board.flask_count[above.color]++

              // only accept white blocks above if empty
              // break if other colors brewed
              } else if (this.color == EMPTY) {

                if (above.color == WHITE) {

                  this.color = above.color 
                  this.sleepcounter = 40
                  console.log("sleepcounter = " + this.sleepcounter)

                  // update sprite data
                  this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), image:"./static/images/POTION_" + COLORS[above.color] + ".gif",anchor:"left"})
                  this.sprite.dx = this.stack.board.posx(above.x)
                  this.sprite.dy = this.stack.board.posy(above.y - 1)

                  // update board count
                  this.stack.board.flask_count[EMPTY]--
                  this.stack.board.flask_count[above.color]++

                // melting colored blocks over empty flask creates an unstable reaction
                } else {

                  var this_stack = this.stack.items

                  console.log("this_stack:")
                  for (var i=this_stack.length-1; i > 0; i--) {
                    console.log (this_stack[i])
                  }

                  this.color = UNSTABLE
                  this.breaking = true 

                  // update sprite data       
                  this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), anchor: "left"})
                  var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_SPRITES.gif", frame_size: [40,40], frame_duration: 20})
                  this.sprite.anim_default = anim.slice(0,6)

                  this.sprite.dx = this.stack.board.posx(above.x)
                  this.sprite.dy = this.stack.board.posy(above.y - 1)

                  // update board count
                  this.stack.board.flask_count[EMPTY]--
                  this.stack.board.flask_count[this.color]++
                }

              }

            }
          }
           
        }

        // player name and timer
        this.draw = function() {
          this.sprite.draw()
        }
      }

      /* Constructor for Splashes */
      function Splash(stack,type,color,x,y,delay) {

        // console.log("adding splash")

        this.stack = stack // the stack this splash comes from
        this.type = type   // type of the item destroyed
        this.color = color // color of the item destroyed
        this.x = x         
        this.y = y
        this.delay = delay // delay animation until counter goes to 0

        // set appropriate sprite for this Splash

        this.sprite_sheet = new jaws.SpriteSheet({
          image: "./static/images/ROBOT_" + COLORS[color] + "_SPLASH.gif", frame_size: [20,20]})

        this.sprite1 = new jaws.Sprite({x:this.stack.board.posx(x), y:this.stack.board.posy(y), image: this.sprite_sheet.frames[0]})
        this.sprite2 = new jaws.Sprite({x:this.stack.board.posx(x)+20, y:this.stack.board.posy(y), image: this.sprite_sheet.frames[1]})
        this.sprite3 = new jaws.Sprite({x:this.stack.board.posx(x), y:this.stack.board.posy(y)+20, image: this.sprite_sheet.frames[2]})
        this.sprite4 = new jaws.Sprite({x:this.stack.board.posx(x)+20, y:this.stack.board.posy(y)+20, image: this.sprite_sheet.frames[3]})

        this.initSprite = function(sprite, splash, x_offset, y_offset) {

          x_offset = typeof x_offset !== 'undefined' ? x_offset : 0;
          y_offset = typeof y_offset !== 'undefined' ? y_offset : 0;

          sprite.x0 = sprite.dx = this.stack.board.posx(splash.x) + x_offset
          sprite.y0 = sprite.dy = this.stack.board.posy(splash.y) + y_offset
          sprite.t = 0

        }

        this.initSprite(this.sprite1, this)
        this.initSprite(this.sprite2, this, 20)
        this.initSprite(this.sprite3, this, 0, 20)
        this.initSprite(this.sprite4, this, 20, 20)

        this.spriteExplode = function(sprite, splash, direction) {

          // console.log("spriteExplode")
          sprite.t += 3
          sprite.dy = sprite.y0 + .1 * sprite.t * sprite.t - 4 * sprite.t
          sprite.dx = sprite.x0 + (direction) * sprite.t

        }
        
        this.update = function() {

          if (this.delay <= 0) {
            // console.log ("updating splash sprites")
            this.spriteExplode(this.sprite1, this, -1)
            this.spriteExplode(this.sprite2, this, 1)
            this.spriteExplode(this.sprite3, this, -.5)
            this.spriteExplode(this.sprite4, this, .5)

            // update splash sprite positions
            spriteMove(this.sprite1,X_SPEED,Y_SPEED)
            spriteMove(this.sprite2,X_SPEED,Y_SPEED)
            spriteMove(this.sprite3,X_SPEED,Y_SPEED)
            spriteMove(this.sprite4,X_SPEED,Y_SPEED)
          } else {
            this.delay--
          }
          
        }

        this.draw = function() {

          if (this.delay > 0)
            return

          this.sprite1.draw()
          this.sprite2.draw()
          this.sprite3.draw()
          this.sprite4.draw()

        }

      }

      function Timer(player) {

        this.player = player
        this.minutes = 0
        this.seconds = 0
        this.ticker = 0
        this.clock_text = "00:00"

        // increment the ticker and count the seconds and minutes
        this.update = function() {
          this.ticker++
          if (this.ticker >= 60) {
            this.ticker = 0
            this.seconds++
          }
          if (this.seconds >= 60) {
            this.seconds = 0
            this.minutes++
          }

          var min_text = (this.minutes < 10) ? "0" + this.minutes : this.minutes
          var sec_text = (this.seconds < 10) ? "0" + this.seconds : this.seconds

          this.clock_text = min_text + ":" + sec_text

        }

      }

      function spriteMove(sprite,x_speed,y_speed) {
        if (Math.abs(sprite.x - sprite.dx) < x_speed) sprite.x = sprite.dx
        else if (sprite.x < sprite.dx) sprite.x += x_speed
        else sprite.x -= x_speed

        if (Math.abs(sprite.y - sprite.dy) < y_speed) sprite.y = sprite.dy
        else if(sprite.y < sprite.dy) sprite.y += y_speed
        else sprite.y -= y_speed
      }
    
    }

    function fisherYates ( myArray ) {
      var i = myArray.length, j, temp;
      if ( i === 0 ) return false;
      while ( --i ) {
         j = Math.floor( Math.random() * ( i + 1 ) );
         temp = myArray[i];
         myArray[i] = myArray[j]; 
         myArray[j] = temp;
       }
    }

    function saveRecord (record) {
      console.log("savingRecord()")
      jQuery.ajax({
        type: "POST",
        data: record,
        success: function(data) {
          console.log("record POSTed to server")
          }
      });
    }

    /*
    *
    * MenuState is our lobby/welcome menu were gamer can chose start, high score and settings.
    * For this example we have only implemented start. Start switches active game state by simply:
    *   jaws.switchGameState(play)   (jaws.switchGameState(PlayState) would have worked too)
    *
    */
    function MenuState() {
      var index = 0
      var items = [player_level, "-", player_stage]

      this.setup = function() {
        index = 0
        jaws.on_keydown(["left","a"],       function()  { index=0; if(index >= items.length) {index=items.length-1} } )
        jaws.on_keydown(["right","d"],         function()  { index=2; if(index < 0) {index=0} } )
        jaws.on_keydown(["up","w"], function() {
          if (index==0) {
            if (player_level < 6) {
              player_level++
              items[index] = player_level
            }
          } else if (index==2) {
            if (player_stage < 6) {
              player_stage++
              items[index] = player_stage
            }
          }
        })
        jaws.on_keydown(["down","s"], function() {
          if (index==0) {
            if (player_level > 1) {
              player_level--
              items[index] = player_level
            }
          } else if (index==2) {
            if (player_stage > 1) {
              player_stage--
              items[index] = player_stage
            }
          }
        })
        jaws.on_keydown(["enter","space"],  function()  { 
          jaws.switchGameState(Game) 
        } )

        // control mode
        jaws.on_keydown(["c"], function() {
          if(control_scheme == 1) control_scheme = 2
          else if (control_scheme == 2) control_scheme  = 1
        })

        // game mode
        jaws.on_keydown(["m"], function() {
          if(game_mode == 1) game_mode = 2
          else if (game_mode == 2) game_mode  = 1
        })
      }

      this.draw = function() {
        jaws.context.clearRect(0,0,jaws.width,jaws.height)
        for(var i=0; items[i]; i++) {
          // jaws.context.translate(0.5, 0.5)
          jaws.context.font = "bold 50pt terminal";
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  (i == index) ? "Red" : "Black"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(items[i], 225 + i * 60, 225)
        }
        jaws.context.font = "bold 30pt terminal";
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Black"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText(" (c)ontrols: " + control_scheme, 200, 400)

        jaws.context.font = "bold 30pt terminal";
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Black"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText("(m)ode: " + game_mode, 210, 450)  
      }
    }    
    
    jaws.onload = function() {
      console.log("Board is filled according to level-stage. Working on win/lose conditions.")
      console.log("TODO: update breaking condition ")
      console.log("Bugs: need to check if there's enough flasks for lose condition")
      jaws.unpack()     
      jaws.assets.add(["./static/images/cursor.gif","./static/images/BLUE.gif","./static/images/GREEN.gif","./static/images/RED.gif","./static/images/YELLOW.gif","./static/images/PURPLE.gif","./static/images/WHITE.gif","./static/images/ORANGE.gif","./static/images/POTION_EMPTY.gif","./static/images/POTION_BLUE.gif","./static/images/POTION_GREEN.gif","./static/images/POTION_RED.gif","./static/images/POTION_YELLOW.gif","./static/images/POTION_PURPLE.gif","./static/images/POTION_WHITE.gif","./static/images/POTION_ORANGE.gif","./static/images/POTION_SPRITES.gif","./static/images/ROBOT_RED.gif","./static/images/ROBOT_WHITE.gif","./static/images/ROBOT_YELLOW.gif","./static/images/ROBOT_PURPLE.gif","./static/images/ROBOT_GREEN.gif","./static/images/ROBOT_BLUE.gif","./static/images/ROBOT_ORANGE.gif","./static/images/ROBOT_RED_DEATH.gif","./static/images/ROBOT_YELLOW_DEATH.gif","./static/images/ROBOT_PURPLE_DEATH.gif","./static/images/ROBOT_RED_SPLASH.gif","./static/images/ROBOT_BLUE_SPLASH.gif","./static/images/ROBOT_YELLOW_SPLASH.gif","./static/images/ROBOT_GREEN_SPLASH.gif","./static/images/ROBOT_PURPLE_SPLASH.gif","./static/images/ROBOT_ORANGE_SPLASH.gif","./static/images/BOARD.gif"])
      jaws.start(MenuState)  // Our convenience function jaws.start() will load assets, call setup and loop update/draw in 60 FPS
    }

  </script>

</body>
</html>

